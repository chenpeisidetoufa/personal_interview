一、储存持续性（不同的方案保留在内存的时间不同）：
*自动储存持续性：两种（函数参数和普通变量）
*静态储存持续性：三种（链接性不同的三种） static和函数定义外定义的变量
*线程储存持续性(C++11)：整个线程存在,thread_local
*动态储存持续性: new

二、作用域（描述在多大范围内可见）：
*局部：
*全局（文件作用域）：定义位置到达文件尾，静态变量的作用域是全局还是局部取决于如何被定义
*类作用域：类成员，作用域为整个类，成员函数可以直接使用私有成员或另外对象的私有成员，就是因为加了类名::之后的成员函数体内属于本类的作用域。
*名称空间作用域：在名称空间中声明的变量，作用域为整个名称空间

三、链接性（如何在不同文件（翻译单元）间共享）：
*无链接性：只能在当前函数或代码块中访问
*内部链接性：只能由一个文件中的函数共享
*外部链接性：文件间共享 （通常为静态持续性）

*静态持续变量：
	有三种链接性：无链接性、内部链接性、外部链接性。这三种在整个程序执行期间存在
	在代码块外面不使用static声明的静态变量链接性为外部、作用域：全局
	在代码块外面使用static声明的静态变量链接性为内部、作用域：全局
	在代码块内使用static声明的静态变量链接性：无链接性、作用域：局部。
	在函数中使用static声明的静态变量链接性：无连接性、作用域：函数体。这种方式的初始化语句只执行一次。要注意在相同代码块内不能定义相同的静态变量多次。
	还有一种在类内的情况，要看声明在私有、保护、还是公有
*静态变量的初始化：
	零初始化：默认情况下，不显示初始化，包括数组元素，结构元素将初始化为0
	静态初始化：static int a = 0;  //其实也是先进行了零初始化
	动态初始化：static int a = 4.0 * atan(1.0);  //其实也是先进行了零初始化
*静态持续性、外部链接性：
	extern(引用声明，不分配空间，想要使用其他文件中定义的静态外部变量，使用extern引用声明（必须的）)
	extern int a;  //这句话不分配空间 extern int a = 2;//这句话分配了空间相当于声明,同一变量只能初始化一次
	extern还有一个作用，就是显示声明变量链接性为外部的
	一般情况下不允许把静态外部变量放在头文件中定义，因为在程序中会有多个地方包含一个头文件，这个头文件被编译多次，静态外部变量会被多次定义，报错。

*所有的静态变量在编译阶段就确定了大小和偏移地址，存放在全局区。

*使用常量表达式初始化的const对象也是常量表达式（常量表达式指的是在编译阶段就知道了结果）！因此const对象有可能和静态变量储存在一个区（全局区）。

*作用域解析符(::)： :: 变量名 表示使用变量的全局版本

四、const和链接性：
      在默认情况下全局变量的连接性是外部的：即在代码块外面定义的变量 int a = 0;
      这种情况加了const 链接性为内部的，并且不可修改。相当于 static const int a  = 0;不同的是：const int a 必须显示初始化，static const int a默认零初始化
      若希望某个常量链接性为外部：extern const int a = 0;

五、函数和链接性：
*默认情况下函数的持续性为静态持续性，链接性为外部
*函数也同理：如果想要定义一些程序公有的函数，那么在某个cpp文件中定义这些函数（这些函数分配了内存空间成为对象），
 	     然后在使用这些函数的文件中重新引用声明函数：void fun(); 或者extern void fun();
*同样函数也遵循但单定义准则。因此不推荐将函数定义写在头文件，但推荐将函数原型写在头文件，这样只要在使用文件包含了头文件，就不用重新引用声明（void fun(); 或者extern void fun();）

六、include、#ifndef #define ...和链接性：
*链接性为外部的, 那么，程序中包一次头，对所有文件来说都有了这个外部变量的定义，根据单定义原则,程序如果多个地方include了这个头文件，会报重复错误
*class 声明的类类型，链接性应该是内部。在程序中不同文件中多次包含此类头文件也不会报错
  但是如果在同一文件中，此类头文件被编译了两次（比如，另一个头文件中也包含了此头文件，程序中同一文件包含了此头文件又包含了上述另一个头文件），那么会报重复定义错误。
  这就是#ifndef #define ...的作用，加了#ifndef #define ...就不会被编译两次
  #ifndef #define ... 只是防止在同一文件（并不是针对整个程序）中编译多次相同的内容
*const 全局变量也类似class，链接性为内部，因此如果将这种const 全局变量放在头文件中，该头文件在程序不同地方被包含多次不会报错。
  enum定义的枚举也是一种数据类型，链接性也为内部，类似class，常写在头文件
  但是注意理解const全局变量和class 、enum 定义的类型的区别：前者是个变量，是个对象，有内存空间，而后者只是定义了某种类型，并不会占用空间。

七、名称空间（可以声明名称（变量、常量等等）的区域）目的是解决名称冲突问题：
* 名称空间只是一个空间，刚开始这个空间的内容很少，比如std，但是随着被编译的内容越来越多，内容就会越来越丰富。
   在程序运行过程中编译一次头文件<iostream>就会在std中添加许多新内容
* 名称空间不能声明在代码块内，可嵌套。名称空间的名字不怕被多次定义。只要存在testSpace名称空间，那么程序中的所有用到名称空间TestSpace的地方都指的是此名称空间
* 名称空间的作用域和连接性：在自定义名称空间中声明的名称规则与全局名称空间中是一致的。
			namespace TestSpace	//注意：名称空间TestSpace的作用域为全局，链接性为外部的，但是要让已存在名称空间在当前文件能用，必须首先引用此名称空间
						              namespace TestSpcae这句语句，如果已有名称空间TestSpace存在，那么引用已有名称空间，作用类似于extern
						              如果没有名称空间TestSpace已经存在，那么新建名称空间TestSpace
			{
				int a;  		//这种情况变量a的作用域全局，链接性外部，因此程序中多处包含定义TestSpace的头文件会报错重复定义
				const int b = 1;	//这种情况常量b的作用域为全局，链接性为内部，因此不会报重复定义
				static int c = 2;	//这种情况静态变量c的作用域为全局，链接性为内部，也不会报错
				extern int d;	//这句话引用了其他文件中的链接性为外部的d，如果名称空间TestSpace已经存在d，那么想要在当前文件中使用d，必须加上这句话。
			}
* 全局名称空间：实际上代码块外面的“空白区域”也是一种名称空间，这个区域就叫做全局名称空间，通常所说的全局变量都在全局名称空间中，这个区间声明的名称不需要用使用作用域解析符来访问。
   实际上用户定义的名称空间均嵌套在全局名称空间中，而用户定义的名称空间中的名称需要用作用域解析符来访问
* using声明和using编译指令：实际上就是将名称空间中的名称导入到上一级名称空间中，在上一级名称空间中不用再使用作用域解析符，
		               这句话的作用域（指的是这句话的作用范围，不是指using的名称的作用域），类似变量
  using声明：using std::cout; //使特定名称导入到上一级名称空间中
	    using声明和作用域：类似普通变量
		int main()
		{
			using std::cout;	  
			cout << 3;
			return 0;
		}

		void fun()
		{
			cout << 3;   // 这句话错误，因为在main()中using声明的cout对象作用域只在mian代码块
		}
   using编译指令: using namespace std; //使名称空间中所有名称导入到上一级名称空间中
	自定义名称空间中嵌套一个名称空间
	在名称空间中使用using声明和using编译指令：
			namespace TestSpace
			{
				using TestSpace1::a;    //两种方式都可以访问a TestSpace::a;  或   TestSpace1::a;
				using namespace TestSpace2;  //这句话，将TestSpace2中的名称导入到TestSpace中。可以利用TestSpace2再把这些名称导入到全局名称空间
			}
* 无名称名称空间：作用域与有名称的一样，只不过内部名称的链接性为内部。无法在其他文件使用，此时名称空间链接性为外部的变量被多次包头不会报错重复定义
	              可以代替链接性为内部的静态变量static int a;
* 名称空间的使用：
	1.首先要保证名称空间（或者名称空间内想使用的内容）被编译过（头文件只有在被cpp包含的时候才会被编译，cpp文件一定会被编译）
	   并且要让名称空间在使用文件可见：包头（头文件其实也是使用了语句namespace TestSapce {}）或者语句namespace TestSapce {}
	2.在头文件里使用名称空间时，最好不把链接性为外部的变量定义在头文件名称空间，防止包头时重复定义
	3.或者使用无名称名称空间，此时名称空间中的名称链接性都是内部的。代替静态的链接性为内部的变量。
	4.名称空间是开放，分布式使用的，可以在不同地方修改（extern），增加已有名称空间中的内容。
	5.应当先#include 再using namesapce 否则还没有通过编译头文件将想要使用的名称添加到名称空间中，就先将名称空间中的内容导入到上一级名称空间中，有可能影响使用
* 讨论std名称空间：
	首先std名称空间中应该没有存放链接性为外部的内容，或者使用extern引用了已有的链接性为外部的内容，否则，加入程序多处包含头文件<iostream>会报错
	其次在头文件<iostream>中引用到了其他地方(C++底层标准库)定义的名称空间std，然后在std中添加了新内容，
                	实际方式是宏#define _STD_BEGIN	namespace std {）和#define _STD_END		} 来代替 namesapce std {}
	因此包含头文件<iostream>，只能使用<iostream>放在std中的新名称，或者<iostream>文件在std中extern引用的名称。当然这种机制是有好处的。	