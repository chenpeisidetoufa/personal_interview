*栈：不是程序所有的内存开销都存放在栈或者堆中，栈也不是程序每走一步，栈指针都在活动。
        栈可以理解为是程序走向的一种控制器。
        栈里面存放：1.调用函数时，调用函数下一条指令的地址（指令并不存放在栈中）
                            2.函数参数（形参）
	            3.临时变量
*栈和函数调用：
        看下面代码：
	int main(int argc, char *argv[])		//首先把调用main的下一条指令地址存入栈（注意不是语句1指令的地址！而是调用main（）的指令的下一条指令，也许并没有这种指令），
					//然后把参数argc和argv[]存入栈
		{
			语句1;		//这句话也许并不会使栈有变化
			fun(1);		//此时把语句2产生的指令的地址存入栈，再把形参int（1）存入栈
					//fun（1）的内部暂且不管
					//...
					//此时fun（1）执行完毕，先弹出形参int（1），
					//程序读取栈中保存的语句2的指令地址，去执行语句2
					//注意，栈中保存的语句2的指令地址没有在fun（1）执行完之后弹出，
					//可以理解为它相当于main（）函数中产生的临时变量，要等到main（）函数体执行完毕（main（）函数返回时）才弹出
			语句2;		//这句话也许也不影响栈
					//此时，栈中还保存（由上到下）：1.语句2的产生的指令地址；2.main（）函数形参argc、argv[]；3.调用main（）函数指令的下一条指令地址（也许没有）
		}			//main（）结束：弹出语句2产生的指令地址，弹出main（）函数形参
					//至于剩下的调用main（）函数指令的下一条指令地址（也许没有），由系统处理。
*内联函数：
       内联函数不产生函数调用的过程，而是代码替换。
       内联函数仅仅比普通函数的优势：
       	1.运行速度快（没有跳跃调用的过程）
	2.不用在栈中存放调用函数产生的多余栈内存（1、调用指令的下一条指令；2、函数形参）
       但是内联函数产生了多余的重复的代码，占用多余内存（注意不是栈内存）
       不是加了inline就一定是内联函数（或者在类内函数声明定义写在一起，这种情况为隐式内联），具体实现要看编译器行为。

* 关于为什么要设置栈和堆的机制（编程的历史原因）：
   1）有些数据可以让程序自动管理（临时变量、函数参数等），尤其是需要程序帮助我们自动清除！这时候就需要栈（静态内存分配）来完成这部分工作；
         那么这些临时数据的大小我们已经事先编译成机器指令（数组维度需要常量表达式），只要调用到有关函数（中的有关语句 int a = 0；），程序自动帮我们完成这些数据的产生和销毁。
   2)  有些数据需要程序员更加灵活的去控制，控制什么时候产生、什么时候销毁甚至数据的大小！
        这时候就设计了堆的机制：任程序员设置申请的内存大小并且程序员自己选择合适的时机摧毁数据地去动态地管理内存！
        向堆中放入的数据，事先可以不知道大小。可以理解为大小作为参数传给动分配函数！因此编译过程无需知道new出的数据的大小，数组的维度也可以是变量。
   3）来看这个例子：	int a = fun();                             //a在栈中，静态内存分配，编译阶段已经知道该给其划分多大的空间，但是其具体值要在运行阶段才能确定
  		int *arr = new int[a]; 	//arr指向的数组，在编译阶段不知数组的大小，只有运行阶段（a的大小确定后）才确定其大小。
        

       