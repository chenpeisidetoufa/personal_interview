*何时调用构造函数：
	//explicit规定，只能使用()方式直接调用各种构造函数
	Test a(1);
	Test b = 3;  //如果构造函数是explicit的，不能使用这种形式
	Test b = Test(3);  	//编译器优化，有可能使用3构造一个临时对象，再用临时对象拷贝构造b，VS2013直接使用3构造b，
			//注意，如果构造函数是explicit的，可以使用这种形式，但是如果拷贝构造函数是explicit的，不管是否优化都不能使用这种形式！
			//也就是说编译器首先按照不优化的逻辑检查代码，然后再优化
*何时调用复制（拷贝）构造函数：使用已有对象初始化对象时：
	Test b(a);
	Test b = a;     	//如果拷贝构造函数是explicit的，不能使用这种形式
	Test b = Test(a);  	//编译器优化，有可能先用a拷贝构造一个临时对象，再用临时对象拷贝构造b，VS2013直接使用a拷贝构造b，同样如果拷贝构造函数是explicit的，不能使用这种形式
*何时调用赋值运算符：将已有的对象赋值给另一个已有的对象时
	a = b;
*函数返回、函数形参和复制构造函数（编译器优化）：
  return产生的临时对象若有承接方，那么return和构造新对象将合并完成。若没有承接方，return时也会调用相应版本构造函数产生临时对象，并立马析构。
	TestA fun(TestA test)                //形参，参数传入时一定使用复制构造函数
	{
		return test;
	}
	TestA fun(TestA & test)                //参数为引用，不使用复制构造函数
	{
		return test;
	}
	下面使用引用版本：
	fun(a);  	//若单独运行函数，函数返回时，调用复制构造函数（执行return时）产生临时对象，紧接着析构临时对象
	TestA b  = fun(a);    	//编译器优化， return时产生副本和构造新对象合并完成，直接把test复制构造给b了（执行return时）, 函数返回时并没有产生多余的临时对象（因此无需析构临时对象），也就是说return test 和 构造b是同时完成的
	TestA & b  = fun(a);  // 执行return时，复制构造了新临时对象，并且此对象直接被引用，不立即析构，有了生命周期。其实标准写法应该为TestA && b = fun(a); 因为新的临时对象为右值，若为基础类型，报错！
	TestA& fun(TestA & test)   //返回引用（函数本身不会调用复制构造函数），注意此时不要return函数中的临时变量，
			         //有时返回临时变量不会出错，比如又用引用绑定了返回的引用，那是因为程序没有对已经析构的临时变量那块内存进行操作，已经析构的那块内存的数据没变，
		       	         //但是一旦程序对那块内存做了改变，那么再使用绑定了返回的引用的引用，将会出错，而且这种错误很难寻找！
	{
		return test;
	}
	fun(a);  	//没有复制构造函数
	TestA b  = fun(a);	//构造b时使用复制构造函数（用返回的引用构造，执行TestA b时）
* 进入构造函数体之前完成所有类对象成员的初始化（即构造）（基本类型不赋予初始值，只是开辟了空间，初始值为空间原来的值），
  同样继承的基类组件，若不使用初始化列表初始化，也将先调用基类的默认构造函数（如果存在的话）
  如果使用初始化列表，则在初始化列表时完成类对象的初始化（使用相应版本的构造函数），因此初始化列表效率更高。
* 在类的成员函数中可以直接访问该类型实例对象的私有成员，比如复制构造函数可以直接访问传进来的私有成员