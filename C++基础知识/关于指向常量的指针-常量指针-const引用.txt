*指向常量的指针：
 const char * p;
*常量指针（指针本身是常量）
 char * const p;

*顶层const: 指针（任何数据类型）本事是个常量；
 底层const：指针（引用、二者组合）指向的对象是个常量

* 数组名是常量指针
  注意双引号字符串（与普通数组/数组名的区别）："abc"; 	//总之，符号“abc”很特殊，在不同的语境中表示不同的意思
                                                            		//“abc”可以被取地址&("abc")返回指向数组的指针（类似于&(数组名)），形式为const char (*) [4]，因此不能用&("abc")赋值给const char *，
                          				//&("abc")这个语境下"abc"表示类型为const char [4],注意与普通数组区分，普通数组表示char [4](没有const)
		               			//也可以被引用const char(&pr)[4] = "abc"; 这个语境下“abc”也表示类型为const char [4]
					//char(&pr)[4] = "abc"; 错误，无法从“const char [4]”转换为“char (&)[4]
                                               			//char *pt = "abc"; 这个语境“abc”表示为 char * 类型，因此可以用来初始化非const的char*类型，
					//但是如果强行使用此指针修改“文字常量区”（*pt）= ‘b’; 能通过编译，但是程序运行会崩！ 
*数组名[]：实际上，使用数组名参加下标运算时本质上参加运算的仍然是指向数组首元素的指针：arr[2] 实际的运算过程是这样的：*(arr + 2)
 地址解引用符返回的是对象本身，不是对象的拷贝。

*如果 指针为底层const： const char* p; 那么 (p + 1)同样为底层const，语法：*(p + 1) = 'a';是错误的！

*数组的维度必须（除了new）是常量表达式（在编译阶段就得到计算结果）。对于这个问题下面做更深的解释：
 1）首先程序编译阶段需要知道所有类型的大小，才能翻译成正确的计算机指令。
 2）假如需要在静态区创建数组，静态变量必须在编译阶段完成偏移地址和大小的确定。因此需要在编译阶段就要知道数组的维度！
 3）假如需要在栈内存创建数组，那么首先也要知道这个数组需要多大空间，才能翻译成正确的机器指令。
      假如这个数组的维度的大小只有运行时才能知道。比如说int* sz = new int; int arr[(*sz)]；这种情况下，编译阶段无法完成生成指令工作。
 4）再看一种情况：我们想要定义静态数组，我们知道，静态变量需要在编译阶段确定大小和初始值，此时数组维度必须在编译阶段就确定！
 5）非数组不存在以上两种问题，C++索性规定数组维度常量确定。
 6）唯独在堆内存创建数组时（new），由于堆内存中数据的大小、值和地址是在运行阶段知道的。
      此时：int sz = 3; int *parr = new[sz]；可行
 6）实际上现在很多编译器已经支持动态维度数组，编译不会报错，但是实质上这种用法还是跟动态内存分配息息相关!

*使用常量表达式初始化的const对象也是常量表达式！因此const对象有可能和静态变量储存在一个区（全局区）。

*数组的指针： int (*p)[10]  = &arr; 
 指针的数组：int *p[10];
 数组的引用：int (&r)[10] = arr;
 不存在引用的数组：int &rs[10];

*const值在初始化之后不能改变
 作为函数参数

*引用只有一种const int & temp;
 还有一种写法int & const temp;
 两种写法等效，不能用此引用修改引用指向的值（对象）。

*考虑：
	int a[2] = {1,2};
	a = 0x804a014
	&a = 0x804a014  //若a是指针对象，那么&a指的是指针对象的地址，两个地址应该不一样
	a + 1 = 0x804a018
	&a + 1 = 0x804a01c
 在几乎所有使用数组的表达式中，数组名的值是个常量指针
 如果它们是int类型，那么数组名的类型就是“指向int的常量指针“
 在以下七种场合下，数组名（与其说数组名不如说类型为int[4]的对象在这七种情况下）并不是用常量指针来表示，就是当数组名作为sizeof操作符、单目操作符&的操作数时、数组被引用(包括auto & arr1 = arr;和int *& p = arr;)时、decltype()、范围for循环、begin()/end()函数和typeid。
 普通对象数组（int a[5] 、char a[5]...）：这七种情况下数组名表示类型为int [5]，是否为const int [5]取决于数组本身是否为const（const int a[5]）；
 假如普通对象数组被定义为const（const int a[5]）,此时数组中的元素也为const类型，不可修改；
 普通对象数组（int a[5] 、char a[5]...）在其他情况下的类型为（int const*、char const*），可以用来初始化（非const）指针类型
 双引号字符串（“abc”）在这七种情况下类型为const char[4];
 双引号字符串（“abc”）在其他情况下的类型为也首字符地址char const* ，可以用来初始化（非const）char* 类型。但是使用这种指针改变指向元素程序崩溃！
 sizeof返回整个数组的长度（字节），而不是指向数组的指针的长度。 
 取一个数组名的地址所产生的是一个指向数组的指针，而不是一个指向某个常量指针的地址；
 数组被引用int (&r) [5] = arr; //arr为数组名，类型为int [5] ；
 decltype(arr) arr1; //arr的类型为数组

*考虑特殊情况：
	int arr[3] = { 0 };
	int *& p = arr;  	//这种语境下 声明为指针的引用 报错：无法从“int [3]”转换为“int *&”因此这种语境下数组类型也被当做int[3]
  我们可以首先将数组名赋值给指针，再引用：
	int * p = arr;
	int *& pp = p;

* 数组作为形参：
   	void fun(int *arr);
	void fun(int arr[]); 		//注意，与数组直接初始化赋值不同 ar是实参数组，直接拷贝初始化 int arr[] = ar，编译不通过，作为形参编译可以通过，因为编译器提前把形参类型转为int*
	void fun(int arr[10]); 	//同上
	以上三种完全等价，编译器都把形参类型转为int*，维度不起作用
 	void fun(int (&arr)[10])
	使用数组的引用作为形参，arr的类型就是数组的引用。
*数组作为返回值：
	不能把数组类型直接当做函数返回值，往往执行拷贝时，数组转为指针类型，但是可以使用数组的引用或者指向数组的指针来作为函数返回值
	int(*fun(int a))[10] //返回类型为(int*)[10]
	{
		int arr[10][10];
		int(*p)[10] = arr;
		return p;
	}
	int (&fun(int i))[10];	//返回类型为(int&)[10]

	int(&fun(int a))[10]
	{
		int arr[10];
		return arr;
	}
*二维数组：
 int ia[3][4];     //ia的类型如果不是上述七种场合下，其类型编译器认ia的类型为是个常量指针，这个指针指向了存放了类型为int[4]的对象，那么此时ia的类型编译器认为是 int(*)[4]  const
                      //如果在上述七种场合下，编译器认为ia的类型是int[3][4]
 for(auto au : ia);    //范围for循环这种情况下，ia的类型编译器认为是const int[3][4], auto可以理解为 ：依次返回数组内部元素; 内部元素的类型是int[4],我们知道int[4]这种类型在除了上述七种情况下类型编译器都认为是int * const，因此au的类型为int *
 for(auto aw : au);  //此时再对其进行范围for循环，编译报错！因此au的类型是int *
 再看来：
 for(auto& au : ia);    //范围for循环这种情况下，ia的类型编译器认为是int[3][4], auto可以理解为 ：依次返回数组内部元素; 内部元素的类型是int[4],我们知道int[4]这种类型在上述七种情况下类型编译器都认为是int[4]，因此au的类型为int(&)[4]
 for(auto aw : au);  //此时再对其进行范围for循环，因此au的类型是int[4],aw的类型是int
 for(auto& aw : au); //此时再对其进行范围for循环，因此au的类型是int[4],aw的类型是int &


