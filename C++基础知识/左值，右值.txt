* 左值右值的形式区分（或者称语法区分）是能否用取地址&运算符（是否可被引用）；
  语义区分（即其本质涵义）在于表达式代表的是持久对象还是临时对象（是否占用内存空间，是否编译为为汇编中的立即数）。
* 当对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。
* 左值包括：变量、数组、数组元素、结构成员、引用（包括右值引用）、解除引用的指针、指针变量（因为指针变量可以取地址，也可以被引用）、
	   双引号字符串也属于左值、const变量（不可修改的左值)
                  int a = 1;
	  int * pt = &a;
	  int *& y = &a;   //不可以，因为&a是地址本身而不是指针变量，不可以被引用，也不可以取地址，也没有专门为其开辟的内存空间，&a为右值
                  int *& y = pt;    //可以，指针变量可以被引用，也可以取地址

	  我的理解(关于双引号括起来的字符串)：
	  "abc";   //符号“abc”在不同的语境中表示不同的意思
                                 符号"abc"可以被取地址&("abc")返回指向数组的指针（类似于&(数组名)），形式为const char (*) [4]，因此不能用&("abc")赋值给const char *，也可以被引用const char(&pr)[4] = "abc";
                                 符号“abc”在不同的语境中，表示的内容不一样，C++规定双引号字符串为左值！存放在文字常量区！
* 右值（非左值）包括：字面常量（地址本身、除了双引号括起来的字符串字面常量）、包含多项的表达式，（x + y， 其中x、y为基本数据类型，此时x + y 为右值，如果使用自定义类型operator+ 情况与函数返回值相同），
                                  函数返回产生的临时对象（如果为自定义类，返回的临时对象是有内存空间的，可以取地址和引用，某种意义上为左值（其实还是为右值），如果返回基本类型，则没有内存空间，因此为右值）
                                  但是，C++标准中明确说只有返回引用类型才可以称之为左值，所以为此，争论不休，今天也没有个结果！
		  使用点运算符时，如果成员所属的对象是左值，那么结果是左值；反之，如果成员所属的对象是右值，那么结果是右值。
* 右值引用：
	std::move()返回无名右值引用（也为右值）
	static_cast 也可以将左值转换为无名右值引用（也为右值）
                TestA & b = static_cast<TestA &&> (one);    //可以
	int & b = static_cast<int &&> (1);  //不可以
	TestA & b = std::move(one);  //可以
	int & b = std::move(1);   //不可以 
                这也解释了为什么右值可以使用参数为左值引用fun（TestA & a）的函数
   右值引用只能引用C++规定的右值！而左值引用也可以引用自定义类型的右值。
   右值引用一旦有了名字就是左值了（也有了内存空间）：int && a = 3; //a为左值
*  还需要注意一点：const 左值引用 可以引用内置类型右值：
			double & d = 3.0;   //不可以
			const double & d = 3.0 //可以 实质：加了const之后 C++规定被引用实体允许转换为引用类型的临时对象（如果可以的话），此时实际上d引用的是临时对象
	             被const引用后，变为左值，有内存空间
* 通过右值介绍和右值引用的性质可以看出，不是所有的右值都不能取地址和被引用！
  往往自定义类型的右值（函数返回，无名右值引用）是有储存空间的，可以被引用和取地址，
  move（）实际上返回的是无名右值引用，
  基本数据类型的右值（函数返回，无名右值引用）实际上就是个右值引用）没有储存空间，不可以被引用和取地址
* 立即数：立即数不分配内存空间，由编译器管理。
*  关于右值引用的引用折叠：
   对于模板函数（非模板不适用）：	
		template<typename T> 
		void f(T&& arg)
		{
			cout << arg << " " << &arg << endl;
		}
   		f(a)    //a是左值/左值引用 此时编译器推断T类型为int&！
* std::move(u):
	无条件将U转换为右值
* std::forward<T>u:
	当T为左值引用类型时，u将被转换为T类型的左值，否则u将被转换为T类型右值。
	如此定义std::forward是为了在使用右值引用参数的函数模板中解决参数的完美转发问题：
   	template<typename T>
	void fun(T&& arg)		//引用折叠：如果实参为左值或者左值引用那么编译推断T类型为左值引用
		{
			//如果传进Instance函数的参数为左值或者左值引用时，T的类型为左值引用(例如：int &)，此时arg将被转换为左值
			//如果传进Instance函数的参数为右值，那么T的类型为右值引用，此时arg将被转换为右值,这种特性称为完美转发
			T a = new T(std::forward<T>(arg));
		}
  